#include <avr/io.h>
#include <avr/interrupt.h>
#include "timer.h"
#define F_OSC 16000000L
#define F_CPU 16000000L

#define COUNTERS_COUNT 5

static volatile uint16_t counters[COUNTERS_COUNT];
static volatile uint8_t check_var;

// Mapping to 10bit ADC inputs to frequencies for VCO output
// We are mapping the 128 notes of MIDI using 440*2^(X-69)/12). But we have 1024 values so a resolution 8 times greater so the formula
// becomes 440*2^((X/8)-69)/12). Then we convert this to the value needed in the OCRx counter to generate that frequency. This yields the following table
// This will map 0-5V (to a 10bit value from the ADC) to a range from 8hz to  12544hz. The scale is exponential
//uint16_t counter_table[] = {7645,7215,6810,6428,6067,5727,5405,5102,4816,4545,4290,4050,3822,3608,3405,3214,3034,2863,2703,2551,2408,2273,2145,2025,1911,1804,1703,1607,1517,1432,1351,1276,1204,1136,1073,1012,956,902,851,804,758,716,676,638,602,568,536,506,478,451,426,402,379,358,338,319,301,284,268,253,239,225,213,201,190,179,169,159,150,142,134,127,119,113,106,100,95,89,84,80,75,71,67,63,60,56,53,50,47,45,42,40,38,36,34,32,30,28,27,25,24,22,21,20,19,18,17,16,15,14,13,13,12,11,11,10,9,9,8,8,7,7,7,6,6,6,5,5};

uint16_t counter_table[] ={7645,7590,7535,7481,7427,7373,7320,7268,7215,7164,7112,7061,7010,6960,6910,6860,6810,6761,6713,6665,6617,6569,6522,6475,6428,6382,6336,6290,6245,6200,6156,6111,6067,6024,5980,5937,5895,5852,5810,5768,5727,5686,5645,5604,5564,5524,5484,5445,5405,5367,5328,5290,5252,5214,5176,5139,5102,5065,5029,4993,4957,4921,4886,4851,4816,4781,4747,4713,4679,4645,4612,4578,4545,4513,4480,4448,4416,4384,4353,4321,4290,4259,4229,4198,4168,4138,4108,4079,4050,4020,3991,3963,3934,3906,3878,3850,3822,3795,3767,3740,3713,3687,3660,3634,3608,3582,3556,3530,3505,3480,3455,3430,3405,3381,3356,3332,3308,3285,3261,3237,3214,3191,3168,3145,3123,3100,3078,3056,3034,3012,2990,2969,2947,2926,2905,2884,2863,2843,2822,2802,2782,2762,2742,2722,2703,2683,2664,2645,2626,2607,2588,2570,2551,2533,2514,2496,2478,2461,2443,2425,2408,2391,2373,2356,2339,2322,2306,2289,2273,2256,2240,2224,2208,2192,2176,2161,2145,2130,2114,2099,2084,2069,2054,2039,2025,2010,1996,1981,1967,1953,1939,1925,1911,1897,1884,1870,1857,1843,1830,1817,1804,1791,1778,1765,1753,1740,1727,1715,1703,1690,1678,1666,1654,1642,1630,1619,1607,1595,1584,1573,1561,1550,1539,1528,1517,1506,1495,1484,1474,1463,1453,1442,1432,1421,1411,1401,1391,1381,1371,1361,1351,1342,1332,1322,1313,1303,1294,1285,1276,1266,1257,1248,1239,1230,1221,1213,1204,1195,1187,1178,1170,1161,1153,1145,1136,1128,1120,1112,1104,1096,1088,1080,1073,1065,1057,1050,1042,1035,1027,1020,1012,1005,998,991,984,976,969,962,956,949,942,935,928,922,915,908,902,895,889,883,876,870,864,857,851,845,839,833,827,821,815,809,804,798,792,786,781,775,769,764,758,753,748,742,737,732,726,721,716,711,706,701,695,690,686,681,676,671,666,661,656,652,647,642,638,633,629,624,620,615,611,606,602,598,593,589,585,581,576,572,568,564,560,556,552,548,544,540,536,532,529,525,521,517,514,510,506,503,499,495,492,488,485,481,478,474,471,468,464,461,458,454,451,448,445,441,438,435,432,429,426,423,420,417,414,411,408,405,402,399,396,393,390,388,385,382,379,376,374,371,368,366,363,361,358,355,353,350,348,345,343,340,338,335,333,331,328,326,324,321,319,317,314,312,310,308,305,303,301,299,297,295,292,290,288,286,284,282,280,278,276,274,272,270,268,266,264,262,261,259,257,255,253,251,249,248,246,244,242,241,239,237,235,234,232,230,229,227,225,224,222,221,219,217,216,214,213,211,210,208,207,205,204,202,201,199,198,197,195,194,192,191,190,188,187,186,184,183,182,180,179,178,176,175,174,173,171,170,169,168,166,165,164,163,162,161,159,158,157,156,155,154,153,152,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,127,126,125,124,123,122,121,120,119,119,118,117,116,115,114,114,113,112,111,110,110,109,108,107,106,106,105,104,103,103,102,101,100,100,99,98,98,97,96,95,95,94,93,93,92,91,91,90,89,89,88,88,87,86,86,85,84,84,83,83,82,81,81,80,80,79,79,78,77,77,76,76,75,75,74,74,73,73,72,72,71,71,70,70,69,69,68,68,67,67,66,66,65,65,64,64,63,63,62,62,61,61,61,60,60,59,59,58,58,58,57,57,56,56,56,55,55,54,54,54,53,53,52,52,52,51,51,51,50,50,50,49,49,48,48,48,47,47,47,46,46,46,45,45,45,44,44,44,43,43,43,43,42,42,42,41,41,41,40,40,40,40,39,39,39,38,38,38,38,37,37,37,37,36,36,36,36,35,35,35,35,34,34,34,34,33,33,33,33,32,32,32,32,31,31,31,31,31,30,30,30,30,29,29,29,29,29,28,28,28,28,28,27,27,27,27,27,26,26,26,26,26,25,25,25,25,25,25,24,24,24,24,24,24,23,23,23,23,23,23,22,22,22,22,22,22,21,21,21,21,21,21,21,20,20,20,20,20,20,20,19,19,19,19,19,19,19,18,18,18,18,18,18,18,18,17,17,17,17,17,17,17,17,16,16,16,16,16,16,16,16,15,15,15,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,12,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4};

uint16_t old_f1;

// Phase-correct PWM, non-inverted
void timer_init() {  
    OCR0A = TIMER_OCR0A; 
    TCCR0A = 1<<WGM01;
    TCCR0B = (1 << CS02) | (1<< CS00); // divided by 1024: 15625 times per second
    TIFR0 = 0; 
    TIMSK0 |= 0b10; 
    check_var = 1;
    TCCR1A = (1<< COM1B1) | (1<< COM1B0) | (1 << WGM11) | (1 << WGM10);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12); // divided by 256: 62500 times per second

    TCCR3A = (1<< COM3B1) | (1<< COM3B0) | (1 << WGM31) | (1 << WGM30);
    TCCR3B = (1 << WGM33) | (1 << WGM32) | (1 << CS32); // divided by 256: 62500 times per second

    TCNT0 = 0;				  
    TCNT1 = 0;				  
    TCNT3 = 0;				  
}

void set_pwm_freq(uint16_t freq1, uint16_t duty1, uint16_t offset, uint16_t duty2)
{
    duty1 = duty1 >> 2L;
    duty2 = duty2 >> 2L;

    uint16_t t1 = counter_table[freq1];
    uint32_t d1 = ((uint32_t)t1*(uint32_t)duty1) >> 8L;  // t*duty/255 

    // The 2nd oscillator is just like the first one but with a slighly faster frequency
    // But this needs to change. It shouldn't be linear. The offset should probably be multiplied by 2 for each octave
    // Or maybe it should represent a percentage of the current full octave (100% would make osc2 = osc1+1octave
    //
    offset = offset >> 6L;
    uint16_t t2 = t1+offset;
    uint32_t d2 = d1;


    OCR1A = t1;
    OCR1B = d1;
    OCR3A = t2;
    OCR3B = d2;
}

// This is called 15625/TIMER_STEP times per seconds
ISR(TIMER0_COMPA_vect) {

    for (uint8_t i = 0; i < COUNTERS_COUNT; i++)
    {
        if (counters[i] != 0) counters[i]--;
    }
}

void set_counter(uint8_t i, uint16_t val) {
    if (i>= COUNTERS_COUNT) return;
    counters[i] = val;
}

uint16_t get_counter(uint8_t i) {
    return counters[i];
}

void check() 
{
    check_var = TIMER_OCR0A;
}
